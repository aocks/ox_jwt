
#+BEGIN_SRC emacs-lisp :exports none
(require 'ox-reveal)

;; Make sure to use version 4.0 and set REVEAL_REVEAL_JS_VERSION below
(setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js@4.0.0/")
(setq org-reveal-plugins '(notes))
#+END_SRC

#+COMMENT: using timestamp:nil suppresses "created at" in title
#+COMMENT: using num:nil prevents slide titles being numbered
#+OPTIONS: timestamp:nil num:nil

#+REVEAL_REVEAL_JS_VERSION: 4
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js@4.0.0/
#+REVEAL_PLUGINS: (notes)
#+REVEAL_THEME: solarized
#+REVEAL_INIT_OPTIONS: fragments:true, transition:'fade'


#+COMMENT: Use `s` to engage speaker mode

#+TITLE: Tips, Tricks, and Reasons for JSON Web Tokens (JWTs)
#+AUTHOR: Emin Martinian

* Code Fragment Example :noexport:

#+BEGIN_SRC python
print("This appears immediately")
#+END_SRC

#+ATTR_REVEAL: :frag appear
#+BEGIN_SRC python
print("This appears after clicking")
#+END_SRC


* JWT: JSON Web Token

Used for authentication/authorization such as:

- front-end client to access back-end or API server
- compact, [[https://datatracker.ietf.org/doc/html/rfc7519][standardized]], secured, customizable
- "state-less" alternative to cookies/sessions
- scalable, performant, distributed trust


#+BEGIN_NOTES
- standard: [[https://datatracker.ietf.org/doc/html/rfc7519][RFC 7519]]
#+END_NOTES

* Why JWTs?

Imagine app with many features + servers + engineers:

#+ATTR_REVEAL: :frag (appear appear appear)
- Load balance, payments, profiles, PII, DB
- Local/remote/international workers + consultants
- How to manage security?
  - Can't give everyone access to sensitive info


* JWT Architecture
#+BEGIN_NOTES
- Auth server manages passwords, takes credit cards, etc.
- Must be secure and in sync; hard to load balance
- Cannot let just any employee have access
#+END_NOTES

Separate authentication from validation/application:
- Authentication requires secret keys (high security)
- Validation can use public key (less security)
- Easier to manage secrets, keys, load, sync, etc.

#+name: jwt-auth-vs-app-start
#+begin_src dot :cmdline -Kdot -Tjpg :exports results :file images/jwt-auth-vs-app-start.jpg

digraph auth_system {
    // Define subgraphs
    subgraph top {
        rank=same;
        AuthServer [label="Auth Server", shape=box];
        hidden [style=invis];
        AppServer [label="App Server", shape=box];
    }

    subgraph bottom {
        rank=same;
        Client [label="Client", shape=box];
    }

    // Define connections
    AuthServer -> Client [label="JWT", constraint=false, splines=ortho, style=invis];
    Client -> AuthServer [label="Authenticate\n(e.g., login\nor OAuth\nor credit card)", constraint=false, splines=ortho, style=invis];
    Client -> AppServer [label="Request Service\nusing JWT", constraint=false, splines=ortho,style=invis];

    // Define hidden edges to force layout
    AuthServer -> hidden [style=invis];
    hidden -> AppServer [style=invis];
    hidden -> Client [style=invis];
}

#+end_src

#+RESULTS: jwt-auth-vs-app-start
[[file:images/jwt-auth-vs-app-start.jpg]]


* JWT: Authentication Request

#+BEGIN_NOTES
Managing the authentication server is more complicated.
- Can't allow just anyone to access/maintain/deploy (has secrets)
- Must maintain state (e.g., current user password) so hard to load balance
#+END_NOTES


Client authenticates to server:

#+ATTR_REVEAL: :frag (appear appear)
- Auth server must be secure
- Payment or Login with username/password/MFA
- May require database check, locks, other slow ops



#+name: jwt-auth-vs-app-auth
#+begin_src dot :cmdline -Kdot -Tjpg :exports results :file images/jwt-auth-vs-app-auth.jpg

digraph auth_system {
    // Define subgraphs
    subgraph top {
        rank=same;
        AuthServer [label="Auth Server", shape=box];
        hidden [style=invis];
        AppServer [label="App Server", shape=box];
    }

    subgraph bottom {
        rank=same;
        Client [label="Client", shape=box];
    }

    // Define connections
    AuthServer -> Client [label="JWT", constraint=false, splines=ortho, style=invis];
    Client -> AuthServer [label="Authenticate\n(e.g., login\nor OAuth or\ncredit card)", constraint=false, splines=ortho];
    Client -> AppServer [label="Request Service\nusing JWT", constraint=false, splines=ortho,style=invis];

    // Define hidden edges to force layout
    AuthServer -> hidden [style=invis];
    hidden -> AppServer [style=invis];
    hidden -> Client [style=invis];
}

#+end_src

#+RESULTS: jwt-auth-vs-app-auth
[[file:images/jwt-auth-vs-app-auth.jpg]]


* JWT: Authentication Response

Server responds with JWT:

#+ATTR_REVEAL: :frag (appear appear)
- header describing JWT
- claims describing information/rights
- signature from Auth Server

#+name: jwt-auth-vs-app-auth-response
#+begin_src dot :cmdline -Kdot -Tjpg :exports results :file images/jwt-auth-vs-app-auth-response.jpg

digraph auth_system {
    // Define subgraphs
    subgraph top {
        rank=same;
        AuthServer [label="Auth Server", shape=box];
        hidden [style=invis];
        AppServer [label="App Server", shape=box];
    }

    subgraph bottom {
        rank=same;
        Client [label="Client", shape=box];
    }

    // Define connections
    AuthServer -> Client [label="JWT", constraint=false, splines=ortho];
    Client -> AuthServer [label="Authenticate\n(e.g., login\nor OAuth)", constraint=false, splines=ortho,style=invis];
    Client -> AppServer [label="Request Service\nusing JWT", constraint=false, splines=ortho,style=invis];

    // Define hidden edges to force layout
    AuthServer -> hidden [style=invis];
    hidden -> AppServer [style=invis];
    hidden -> Client [style=invis];
}

#+end_src

#+RESULTS: jwt-auth-vs-app-auth-response
[[file:images/jwt-auth-vs-app-auth-response.jpg]]


* JWT: Application Request

#+BEGIN_NOTES
- Distributed Trust
- App Server can be load balanced or serverless
- App Server can be maintained with lower security requirements
#+END_NOTES


Client sends JWT to App Server:

#+ATTR_REVEAL: :frag (appear appear)
- App Server validates JWT with public key
- No DB/state/sync/update; can be serverless
- Checks JWT for rights + provides service




#+name: jwt-auth-vs-app-request-app
#+begin_src dot :cmdline -Kdot -Tjpg :exports results :file images/jwt-auth-vs-app-request-app.jpg

digraph auth_system {
    // Define subgraphs
    subgraph top {
        rank=same;
        AuthServer [label="Auth Server", shape=box];
        hidden [style=invis];
        AppServer [label="App Server", shape=box];
    }

    subgraph bottom {
        rank=same;
        Client [label="Client", shape=box];
    }

    // Define connections
    AuthServer -> Client [label="JWT", constraint=false, splines=ortho,style=invis];
    Client -> AuthServer [label="Authenticate\n(e.g., login\nor OAuth)", constraint=false, splines=ortho,style=invis];
    Client -> AppServer [label="Send JWT to\nRequest Service", constraint=false, splines=ortho];

    // Define hidden edges to force layout
    AuthServer -> hidden [style=invis];
    hidden -> AppServer [style=invis];
    hidden -> Client [style=invis];
}

#+end_src

#+RESULTS: jwt-auth-vs-app-request-app
[[file:images/jwt-auth-vs-app-request-app.jpg]]





* Separate Auth From Validation

Auth Server has **secrets**; needs **security** + maintenance

#+ATTR_REVEAL: :frag (appear appear)
- App Server needs public keys; low security
- Easy to deploy App Server(s); e.g., serverless
- Lower security for App Server, logs, debug, etc.

#+name: jwt-auth-vs-app-separate
#+begin_src dot :cmdline -Kdot -Tjpg :exports results :file images/jwt-auth-vs-app-separate.jpg

digraph auth_system {
    // Define subgraphs
    subgraph top {
        rank=same;
        AuthServer [label="Auth Server", shape=box];
        hidden [style=invis];
        AppServer [label="App Server", shape=box];
    }

    subgraph bottom {
        rank=same;
        Client [label="Client", shape=box];
    }

    // Define connections
    AuthServer -> Client [label="JWT", constraint=false, splines=ortho,style=invis];
    Client -> AuthServer [label="Authenticate\n(e.g., login\nor OAuth)", constraint=false, splines=ortho,style=invis];
    Client -> AppServer [label="Send JWT to\nRequest Service", constraint=false, splines=ortho, style=invis];

    // Define hidden edges to force layout
    AuthServer -> hidden [style=invis];
    hidden -> AppServer [style=invis];
    hidden -> Client [style=invis];
}

#+end_src

#+RESULTS: jwt-auth-vs-app-separate
[[file:images/jwt-auth-vs-app-separate.jpg]]






* What do JWTs look like?

Base64 encoded header.payload.signature:

#+ATTR_REVEAL: :frag appear :frag_idx 1
#+BEGIN_src shell
HEADER:     { "alg": "HS256", "typ": "JWT" }
#+END_src

#+ATTR_REVEAL: :frag appear :frag_idx 2
#+BEGIN_src shell
PAYLOAD:    {"sub": "a", "name": "arbitrary data", "iat": 1 }
#+END_src

#+ATTR_REVEAL: :frag appear :frag_idx 3
#+BEGIN_src shell
SIGNATURE:  aIBLdQuQ8z4F50Z4fsBRX21WZR7DUqTWa9GXDAN6-M3
            fsF56vwO9XviIeTz-n-0IcDRqM3nej83ueixpIvGs0g
#+END_src

#+ATTR_REVEAL: :frag appear :frag_idx 4
#+BEGIN_src shell
ENCODED JWT:  eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9
              .eyJzdWIiOiJhIiwibmFtZSI6ImIiLCJpYXQiOjF9
              .aIBLdQuQ8z4F50Z4fsBRX21WZR7DUqTWa9GXDAN6-M3
               fsF56vwO9XviIeTz-n-0IcDRqM3nej83ueixpIvGs0g
#+END_src


#+ATTR_REVEAL: :frag appear :frag_idx 5
Signed using HS256 with secret:
#+REVEAL_HTML: <div style="font-size: 75%;">
#+ATTR_REVEAL: :frag appear :frag_idx 5
#+BEGIN_src python
  MHcCAQEEIOiPNn3IQok5k/pPLHSKW1G2rPkZCkED9RWA54oYS5L1oAoGCCqGSM49AwEHoUQDQgAEtuhKtU
  Cz4bc79LV3sfVHNQ++ALIixWwbhAjnkRMp/MRpcHv97AtJIaSJW75/tC9PQEkPwVkurMP3O+eQhJ5Elw==
#+END_src


#+BEGIN_NOTES
- Use https://jwt.io/#debugger-io to verify/validate/decode
- You can put arbitrary data in the payload:
  - indicate username, roles, rights, restrictions, payments
#+END_NOTES

** Example Key Details

PUBLIC KEY:
#+BEGIN_SRC python :session jwt_example :exports code :python ~/code/ox_jwt/venv_ox_jwt/bin/python3
public_key = '''
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEJ4Au4Cb+KMMqarLlsBcv1+U4gBkv
gYu4S/SidhgeZtIVBo3z8ltvlz/QNTFoZJ70bQMu39EQY10ZW20448Mq/w==
-----END PUBLIC KEY-----
'''
#+END_SRC


SECRET KEY:
#+BEGIN_SRC python :session jwt_example :exports code
secret_key = '''
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIHdYJrZXnSG7PA6f61OaPJJ7st8zNhVTCd6mnryb+ZqgoAoGCCqGSM49
AwEHoUQDQgAEJ4Au4Cb+KMMqarLlsBcv1+U4gBkvgYu4S/SidhgeZtIVBo3z8ltv
lz/QNTFoZJ70bQMu39EQY10ZW20448Mq/w==
-----END EC PRIVATE KEY-----
'''
#+END_SRC


** Loading Keys

#+BEGIN_SRC python :session jwt_example :exports code
import base64
import jwt  #  pip install 'pyjwt[crypto]'
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization

der_secret_key = ''.join(secret_key.split('\n')[2:-2])
sk = serialization.load_der_private_key(
    base64.b64decode(der_secret_key),
    backend=default_backend(), password=None)

der_public_key = ''.join(public_key.split('\n')[2:-2])
pk = serialization.load_der_public_key(
    base64.b64decode(der_public_key), backend=default_backend())


#+END_SRC

#+RESULTS:

** Encoding Example JWT

#+NAME: encoded-jwt
#+BEGIN_SRC python :session jwt_example :exports both :results output
import textwrap

example_jwt = jwt.encode(
    headers={'typ':'JWT', 'alg':'ES256'},
    payload={'sub': 'a', 'name': 'b', 'iat': 1},
    key=sk)
print(textwrap.fill('\n.'.join(example_jwt.split('.')),
      width=46, replace_whitespace=False))
#+END_SRC

#+RESULTS: encoded-jwt
: eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9
: .eyJzdWIiOiJhIiwibmFtZSI6ImIiLCJpYXQiOjF9
: .TPrm2ijE9Rr0boAs2n5ltEMWQY0i5AKsJ-Ew_qb4Yb4Jf
: EKKKRgKnFoXep2AMyVNlJP4sDf1vvkuDq1Bm5-Ukg



** Decoding Example JWT

#+NAME: decoded-jwt
#+BEGIN_SRC python :session jwt_example :exports both :results output
decoded_jwt = jwt.decode(example_jwt, algorithms=['ES256'], key=pk)
print(decoded_jwt)
#+END_SRC

#+RESULTS: decoded-jwt
: {'sub': 'a', 'name': 'b', 'iat': 1}








* Python/Flask Example

Easy to verify/decode using libraries (e.g., =pyjwt=) and compose
checks using decorators:

#+BEGIN_SRC python
@app.route('/support/urgent')
@requires_jwt                  # validates JWT
@jwt_claims(['paid_support'])  # ensures token is for premium user
@jwt_iat(datetime.timedelta(hours=24))  # ensure recent token
def support_urgent():
    ... # process ending support request
#+END_SRC

* Example of =@requires_jwt=

#+BEGIN_SRC python
def requires_jwt(func):
    @wraps(func)
    def decorated(*args, **kwargs):        
        token = request.headers.get("Authorization").split(" ")[1]
        if not token:
            return 'missing token', 401  # if no token return error   
        try:
            g.decoded_jwt = jwt.decode(token, algorithms=['ES256'],
                                       key=current_app.config['J_KEY'])
            check_nbf_and_exp()  # ensure active and not expired
            return func(*args, **kwargs)
        except Exception as problem:
            return f'{problem=}', 401 # return 401 or other error code
    return decorated
#+END_SRC

* Example of =@jwt_claims=

#+COMMENT: should we include or skip if tight on time?
#+COMMENT: or maybe have as backup slide

#+BEGIN_SRC python
def jwt_claims(claims_list):
    def make_decorator(func):
        @wraps(func)
        def decorated(*args, **kwargs):        
            missing = [c for c in claims_list
                       if not g.decoded_jwt.get(c)]
            if missing:
                return f'Missing claims: {missing}', 401
            return func(*args, **kwargs)
        return decorated
    return make_decorator
#+END_SRC

* Separate validation from parsing

#+BEGIN_NOTES
We can go one step beyond separating authentication from validation
and separate validation from parsing.

- aside: NGINX+JWTs can protect stand-alone sites
#+END_NOTES

- Validation can be slow for some keys
- Can use middleware to verify signature
- e.g., NGINX can verify before passing to app server

#+COMMENT: FIXME: consider diagram of NGINX idea

* Traps, Vulnerabilities, and Anti-Patterns

#+ATTR_REVEAL: :frag (appear appear appear)
- Beware using header fields to check signature
  - don't trust =alg= field or limit possibilities
  - be careful with =kid=, =jku=, =jwk=, etc.
- Don't simulate sessions with JWTs
- Token revocation issue: access/refresh tokens


* Revocation via Access/Refresh Tokens
  :PROPERTIES:
  :ID:       b06374ea-7534-4153-b5e6-8e2aa62a24c5
  :END:

#+COMMENT: FIXME: need more work here
#+COMMENT: FIXME: might want diagram here

After initial credential check (e.g., username/password or API
key/secret), Auth server provides:

- "refresh token" with long expiry
  - can be used to get access token without credential check
- "access token" with short expiry
  - can be used to access services

On security events (role changes, credential changes, hacks), auth
server will invalidate refresh token + require new credential check.

* Summary and next steps

#+BEGIN_NOTES
If you are writing a small application, you can quickly and easily put
together a secure system using various JWT libraries.

If you are doing a full enterprise authentication system, you may want
to go with an existing platform. Many of those use JWTs under the hood
so it's still useful to have a high level understanding of the basic diea.
#+END_NOTES

#+ATTR_REVEAL: :frag (none none none appear appear)
- Distributed trust can enable many use cases
- JWTs = secure, efficient, standardized auth tool
- Python decorators = nice way to validate claims
- Libraries:
  - [[https://pyjwt.readthedocs.io/en/stable/][pyjwt]], [[https://flask-jwt-extended.readthedocs.io/en/stable/][flask-jwt-extended]], [[https://django-rest-framework-simplejwt.readthedocs.io/en/latest/][djangorestframework-simplejwt]]
- Platforms:
  - [[https://auth0.com][auth0]], [[https://supertokens.com/][supertokens]], [[https://aws.amazon.com/cognito/][cognito]], [[https://www.keycloak.org/][keycloak]]







